### Sample Quadratic
#include "Function.h"
#include "State.h"

CLASS(SampleQuadratic, "Quadratic function") { public:
  // Declare your parameters and working variables here
  complex C;
  int depth;
  double escape;

  SampleQuadratic(String name, String label, int pspace) : Function(name, label, pspace) {
    // List every parameter you want to appear in the "parameters" section
    // using
    // PARAM(variable, name, type, default-value-parameters-space, default-value-dynamical-space)
    PARAM(C, "C", complex, complex(0, 0), complex(-1,0));
    PARAM(depth, "depth", int, 150, 150);
    PARAM(escape, "escape", double, 1000, 1000);
    // Set the default range for both spaces
    setDefaultRangeParameterSpace(-2.2, 1.4, -1.8, 1.8);
    setDefaultRangeDynamicalSpace(-2, 2, -2, 2);
  }

  //Function *copy() {
  //  Quadratic *f = new Quadratic(name, "", pspace);
  //  return f->copyArgsFrom(this);
  //}

  double iterate_(double x, double y) {
    int i;
    complex z, c;
    if (PARAMETER_SPACE) {
      z = complex(0, 0);
      c.set(x, y);
    } else {
      z = complex(x, y);
      c = C;
    }
    for (i = 0; i < depth; i++) {
      z = z * z + c;
      if (norm(z) > escape * escape) break;
    }
    //debug("%d %d", i, depth);
    return (double)i / depth;
  }

  // Forward orbit: assign f(x) to x
  void orbit(complex &x) {
    x =  x * x + C;
  }

  // Set the parameter in dynamical space
  void setParameter(double x, double y) {
    C.set(x, y);
  }

  void sandbox() {
    // Draws the orbit of the critical point
    complex z = 0;
    int i;
    for (i = 0; i < depth; i++) {
      z = z * z + C;
      SETPIXEL(z.real(), z.imag(), 100);
    }
    SetStrokeColor(0, 0, 0);
  }
};

### Sample Newton
#include "Function.h"
#include "State.h"
CLASS(SampleNewton, "Newton's Method") { public:
  complex a;
  int depth;
  double escape;

  SampleNewton(String name, String label, int pspace) : Function(name, label, pspace) {
    PARAM(a, "a", complex, complex(0.5, 0.866025), complex(0.5, 0.866025));
    PARAM(depth, "depth", int, 50, 50);
    PARAM(escape, "bound", double, 1000, 1000);
    setDefaultRangeParameterSpace(-1, 2, 0, 3);
    setDefaultRangeDynamicalSpace(-0.8, 1.8, -1.04, 1.56);
  }

  Function *copy() {
    SampleNewton *f = new SampleNewton(name, "", pspace);
    return f->copyArgsFrom(this);
  }

  double iterate_(double x, double y) {
    int i;
    complex z;
    if (PARAMETER_SPACE) {
      a.set(x, y);
      z = (1.0+a)/3.0;
    } else {
      a.set(0.5, 0.866025);
      z = complex(x, y);
    }
    for (i = 0; i < depth; i++) {
      z = z*z*(1+a-2*z)/(-a+2*z+2*a*z-3*z*z);
      if (norm(z-a)<(1/escape)||norm(z-1)<(1/escape)||norm(z)<(1/escape))
        return (double)i/depth;
    }
    return 1.0;
  }

  void orbit(complex &z) {
    z = z*z*(1+a-2*z)/(-a+2*z+2*a*z-3*z*z);
  }

  void setParameter(double x, double y) {
    a.set(x, y);
  }
};

### Sample Milnor
#include "Function.h"
#include "State.h"

CLASS(SampleMilnor, "Milnor function") { public:
  // Declare your parameters and working variables here
  complex a;
  int depth;
  double escape;

  SampleMilnor(String name, String label, int pspace) : Function(name, label, pspace) {
    // List every parameter you want to appear in the "parameters" section
    // using ARG(variable, parameter-name, default-value, allowed-values)
    PARAM(a, "a", complex, complex(1, 0), complex(-1,0));
    PARAM(depth, "depth", int, 75, 75);
    PARAM(escape, "bound", double, 1000, 1000);
    // Set the default range for both spaces
    setDefaultRangeParameterSpace(-9, 6, -7.5, 7.5);
    setDefaultRangeDynamicalSpace(-2, 2, -2, 2);
  }

  Function *copy() {
    SampleMilnor *f = new SampleMilnor(name, "", pspace);
    return f->copyArgsFrom(this);
  }

  double iterate_(double x, double y) {
    int i;
    complex z;
    if (PARAMETER_SPACE) {
      a.set(x, y);
      z = 2.0/3.0;
    } else {
      a.set(1, 0); /// Nuria?
      z = complex(x, y);
    }
    for (i = 0; i < depth; i++) {
      z = a * z * z * (z - 1);
      if (norm(z) < 1/(escape*escape)) return 0.9;
      if (norm(z) > escape * escape) break;
    }
    return (double)i/depth;
  }

  // Forward orbit: assign f(x) to x
  void orbit(complex &x) {
    x = a * x * x * (x - 1);
  }

  // Set the parameter in dynamical space
  void setParameter(double x, double y) {
    a.set(x, y);
  }
};

### Sample Tangent
#include "Function.h"
#include "State.h"

CLASS(SampleTangent, "tangent: a tan(z)") { public:
  complex a;
  int depth;
  double escape, pixfactor;

  SampleTangent(String name, String label, int pspace) : Function(name, label, pspace) {
    ARG(a, "a", complex, complex(0, TWO_PI), ANY);
    ARG(depth, "depth", int, 200, ANY);
    ARG(escape, "bound", double, 1000, ANY);
    PARAM(pixfactor, "pixfactor", double, 1,1);
    defaults();
  }
  void defaults() {
    if (PARAMETER_SPACE) {
      setDefaultRange(-6, 6, -6, 6);
    } else {
      a.set(0, TWO_PI);
      setDefaultRange(-9, 5, -7, 7);
    }
  }

  Function *copy() {
    SampleTangent *f = new SampleTangent(name, "", pspace);
    return f->copyArgsFrom(this);
  }

  // Use byte iterate version because we use SETCOLOR
  byte iterate(double x, double y) {
    int i;
    complex z, w, ii;
    ii = complex(0,1);
    complex der, epsilon, u;
    if (PARAMETER_SPACE) {
      a.set(x,y);
      z = a * complex(0,1);
    } else {
      z = complex(x, y);
    }
    if (PARAMETER_SPACE) {
      for(i = 0; i < depth; i++) {
        z = -ii* a * (exp(ii*z)-exp(-ii*z))/(exp(ii*z)+exp(-ii*z));
        if(norm(z) > escape*escape) break;
      }
      if (i < depth - 1) return (byte)(255*i/depth);
      w = z;
      for (i = 1; i < 11; i++) {
        z = -ii* a * (exp(ii*z)-exp(-ii*z))/(exp(ii*z)+exp(-ii*z));
        if (norm(z-w) < 1/escape) break;
      }
      if (i==11) return 255;
      return (byte) (i);
    } else {
      w = z;
      der = complex(1,0);
      for(i = 0; i < depth; i++) {
       der = (a*der)/(cos(z)*cos(z));
        z = -ii* a * (exp(ii*z)-exp(-ii*z))/(exp(ii*z)+exp(-ii*z));
      if (norm(der) > 1.001) {
        epsilon = (z-w)/(der-1);
        if (fabs(epsilon.re) < (0.006/pixfactor)&& fabs(epsilon.im) < (0.006/pixfactor)) return (byte) 255;
      }
      };
      return (byte) 2;
    }
  }
  void orbit(complex &z) {
    complex ii;
    ii = complex(0,1);
    z = -ii* a * (exp(ii*z)-exp(-ii*z))/(exp(ii*z)+exp(-ii*z));
  }
  void setParameter(double x, double y) {
    a.set(x, y);
  }
  void setColors() {
    SETCOLOR(1, 255, 255, 0);
    SETCOLOR(2, 0, 255, 255);
    SETCOLOR(3, 255, 0, 0);
    SETCOLOR(4, 128, 128, 0);
    SETCOLOR(5, 0, 255, 0);
    SETCOLOR(6, 0, 0, 255);
    SETCOLOR(7, 0, 0, 128);
    SETCOLOR(8, 255, 0, 255);
    SETCOLOR(9, 255, 102, 0);
    SETCOLOR(10, 204, 0, 255);
    //  SETCOLOR (200, 204, 255, 255); /*light blue*/
    SETCOLOR (0, 255, 255, 255); /*white*/
  }
};

### Sample CentExponential
#include "Function.h"
#include "State.h"

CLASS(SampleCentExponential, "CentExponential: a (exp(z)-1)") { public:
  complex a;
  int depth, plotpoints;
  double escape;

  SampleCentExponential(String name, String label, int pspace) : Function(name, label, pspace) {
    PARAM(a, "a", complex, complex(0, 0), complex(0.2, 0));
    PARAM(depth, "depth", int, 50, 50);
    PARAM(plotpoints, "plotpoints", int, 50000, 50000);
    PARAM(escape, "bound", double, 500, 500);
    setDefaultRangeParameterSpace(-5, 5, -6, 6);
    setDefaultRangeDynamicalSpace(-2, 12, -7, 7);
  }

  Function *copy() {
    SampleCentExponential *f = new SampleCentExponential(name, "", pspace);
    return f->copyArgsFrom(this);
  }

  double iterate_(double x, double y) {
    int i;
    complex z, w;
    if (PARAMETER_SPACE) {
      a.set(x, y);
      z = -a;
    } else {
      z = complex(x, y);
    }
    for (i = 0; i < depth; i++) {
      z = a * (exp(z) - 1);
      if ((z.real() > escape))  return (double)i/depth;
    }
    return 1.0;
  }

  void orbit(complex &z) {
    z = a * (exp(z) - 1);
  }

  void setParameter(double x, double y) {
    a.set(x, y);
  }

  void sandbox() {
    int i;
    int pixcount = 0;
    complex z;
    z = -a;
    for (i = 0; i < plotpoints; i++) {
      orbit(z);
      SETPIXEL(z.re, z.im, 155);
      pixcount++;
    }
  }
};
